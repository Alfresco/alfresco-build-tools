name: "Terraform"

on:
  workflow_call:
    inputs:
      terraform_root_path:
        description: the path to the root module to apply, auto-detected if not provided
        type: string
        required: false
      terraform_operation:
        description: |
          the terraform operation to perform (plan, apply or destroy).
          If not set, the operation will be determined based on the GitHub event.
          For pull requests, it will run plan and for pushes it will run apply based on the PR plan.
          For pull requests comments, it will run apply if the comment contains 'terraform apply'.
        type: string
        required: false
      terraform_env:
        description: the terraform environment to use (e.g. dev, staging, prod), auto-detected if not provided
        type: string
        required: false
      terraform_default_env:
        description: the default terraform environment to use when auto-detection does not find a specific env (defaults to <terraform_root_path>-dev)
        type: string
        required: false
      create_oidc_token_file:
        description: whether to create a file with an OIDC token for AWS
        type: boolean
        required: false
        default: false
      install_kubectl:
        description: whether to install the kubectl CLI
        type: boolean
        required: false
        default: false
      kubectl_version:
        description: the version of kubectl to install (if install_kubectl is true). If not set, the latest stable version will be installed.
        type: string
        required: false
      tfvars_subfolder:
        description: the subfolder where tfvars files are located (relative to terraform_root_path)
        type: string
        required: false
        default: ''
    secrets:
      AWS_ACCESS_KEY_ID:
        required: false
      AWS_SECRET_ACCESS_KEY:
        required: false
      BOT_GITHUB_TOKEN:
        description: a GitHub token used to fetch terraform modules from private GitHub repositories.
        required: false
      DOCKER_USERNAME:
        required: false
      DOCKER_PASSWORD:
        required: false
      RANCHER2_ACCESS_KEY:
        required: false
      RANCHER2_SECRET_KEY:
        required: false

jobs:
  compute_basic_vars:
    name: compute basic variables
    runs-on: ubuntu-slim
    steps:
      - name: Validate inputs
        env:
          TERRAFORM_OPERATION: ${{ inputs.terraform_operation }}
          TFVARS_SUBFOLDER: ${{ inputs.tfvars_subfolder }}
        run: |
          if [ -z "${TERRAFORM_OPERATION}" ]; then
            echo "terraform_operation is not set, defaulting to github event based handling."
          else
            case "${TERRAFORM_OPERATION}" in
              apply|destroy|plan)
                ;;
              *)
                echo "Invalid terraform_operation: ${TERRAFORM_OPERATION}. Must be 'apply', 'destroy', or 'plan'."
                exit 1
                ;;
            esac
          fi

          if [ -z "${TFVARS_SUBFOLDER}" ]; then
            echo "::warning::tfvars_subfolder input is not set. Consider organizing your tfvars files in a 'vars' subfolder for better structure. Set tfvars_subfolder: 'vars' in your workflow to use this recommended layout."
          fi

      - name: Get branch name
        if: inputs.terraform_root_path == ''
        id: get-branch-name
        uses: Alfresco/alfresco-build-tools/.github/actions/get-branch-name-v2@v15.4.0
        with:
          additional-pr-events: true

      - name: Set outputs
        if: inputs.terraform_root_path == ''
        id: set-outputs
        env:
          PUSH_ON_DEFAULT_BRANCH: ${{ github.event.repository.default_branch == steps.get-branch-name.outputs.branch_name }}
          PR_AGAINST_DEFAULT_BRANCH: ${{ github.event.repository.default_branch == steps.get-branch-name.outputs.base_branch_name }}
        run: |
          echo "is_promotion_pr=${{ env.PUSH_ON_DEFAULT_BRANCH == 'false' && env.PR_AGAINST_DEFAULT_BRANCH == 'false' }}" >> "$GITHUB_OUTPUT"

      - name: Checkout to inspect changes and autodetect terraform root path and environment
        if: inputs.terraform_root_path == '' || inputs.terraform_env == ''
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          ref: ${{ github.event_name == 'issue_comment' && format('refs/pull/{0}/merge', github.event.issue.number) || '' }}
          fetch-depth: 0

      - name: Retrieve PR or last commit changes
        if: inputs.terraform_root_path == '' || inputs.terraform_env == ''
        id: last-changes-diff
        uses: Alfresco/alfresco-build-tools/.github/actions/github-list-changes@v15.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute first changed folder (terraform workspace path)
        if: inputs.terraform_root_path == ''
        id: detect-path
        run: |
          if [ "${{ steps.set-outputs.outputs.is_promotion_pr }}" == "true" ]; then
            PROMOTION_PR_FILTER=$(echo "${BRANCH_NAME}" | cut -d'-' -f1)
            echo "This is a promotion PR so restricting changed files to folders matching ${PROMOTION_PR_FILTER}"
          fi

          first_changed_folder=$(echo "${{ steps.last-changes-diff.outputs.all_changed_files }}" \
            | grep '/' \
            | cut -d/ -f1 \
            | grep -Ev '^(\..*|test)$' \
            | grep "${PROMOTION_PR_FILTER:-}" \
            | sort -u \
            | head -1 || true)

          echo "First changed folder: $first_changed_folder"
          echo "terraform_root_path=$first_changed_folder" >> "$GITHUB_OUTPUT"

      - name: Compute first changed tfvars file (when running against default branch)
        if: inputs.terraform_env == '' && steps.set-outputs.outputs.is_promotion_pr == 'false'
        env:
          TERRAFORM_ROOT_PATH: ${{ steps.detect-path.outputs.terraform_root_path }}
        id: detect-tfvars
        run: |
          first_changed_tfvars=$(echo "${{ steps.last-changes-diff.outputs.all_changed_files }}" \
            | grep -v 'common.tfvars' \
            | grep -E '^${{ env.TERRAFORM_ROOT_PATH }}/.*\.tfvars$' \
            | sort -u \
            | head -1 \
            | xargs -r basename -s .tfvars)

          if [ -z "$first_changed_tfvars" ]; then
            DEFAULT_ENV="${{ inputs.terraform_default_env || format('{0}-dev', env.TERRAFORM_ROOT_PATH) }}"
            echo "No specific tfvars file changed, defaulting to '$DEFAULT_ENV'"
            first_changed_tfvars="$DEFAULT_ENV"
          else
            echo "Automatically selected environment based on tfvars file: $first_changed_tfvars"
          fi

          echo "terraform_tfvars_file=$first_changed_tfvars" >> "$GITHUB_OUTPUT"


      - name: Evaluate environment to target
        id: basic_vars
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ -n "${{ inputs.terraform_env }}" ]; then
            echo "Using environment from input: ${{ inputs.terraform_env }}"
            echo "environment_name=${{ inputs.terraform_env }}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -n "${{ steps.detect-tfvars.outputs.terraform_tfvars_file }}" ]; then
            echo "Using environment from changed tfvars file: ${{ steps.detect-tfvars.outputs.terraform_tfvars_file }}"
            echo "environment_name=${{ steps.detect-tfvars.outputs.terraform_tfvars_file }}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BRANCH_NAME="${{ steps.get-branch-name.outputs.branch_name }}"
          BRANCH_LOWER=${BRANCH_NAME,,}
          if [ "$BRANCH_LOWER" == "main" ]; then
            environment="production"
          elif [[ "$BRANCH_LOWER" =~ ^[a-z][a-z0-9-]{3,}$ ]]; then
            environment="${BRANCH_LOWER}"
          else
            echo "$BRANCH_LOWER is not a valid environment name."
            echo "It must:"
            echo " - start with a letter"
            echo " - contain only lowercase chars, numbers, and hyphens"
            echo " - be at least 4 characters long"
            exit 1
          fi

          echo "Using environment based on branch name: $environment"
          echo "environment_name=${environment}" >> "$GITHUB_OUTPUT"

      - name: Add summary info
        env:
          COMMENT_CONTAINS_TERRAFORM_PLAN: ${{ contains(github.event.comment.body, 'terraform plan') || false }}
          COMMENT_CONTAINS_TERRAFORM_APPLY: ${{ contains(github.event.comment.body, 'terraform apply') || false }}
          TERRAFORM_ROOT_PATH: ${{ (steps.detect-path.outputs.terraform_root_path || inputs.terraform_root_path) }}
        run: |
          if [ -z "$TERRAFORM_ROOT_PATH" ]; then
            echo "### Not running Terraform ðŸš€" >> "$GITHUB_STEP_SUMMARY"
            echo "Could not determine the root path for Terraform. Assuming there are no Terraform changes to apply, so skipping Terraform execution." >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          echo "### Running Terraform ðŸš€" >> "$GITHUB_STEP_SUMMARY"
          echo "- Environment: **${{ steps.basic_vars.outputs.environment_name }}**" >> "$GITHUB_STEP_SUMMARY"
          if [ "${{ env.COMMENT_CONTAINS_TERRAFORM_PLAN }}" == "true" ]; then
            echo "- Operation: **plan**" >> "$GITHUB_STEP_SUMMARY"
          elif [ "${{ env.COMMENT_CONTAINS_TERRAFORM_APPLY }}" == "true" ]; then
            echo "- Operation: **apply**" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "- Operation: **${{ inputs.terraform_operation || ((github.event_name == 'pull_request' || github.event_name == 'pull_request_review') && 'plan' || 'apply') }}**" >> "$GITHUB_STEP_SUMMARY"
          fi
    outputs:
      environment_name: ${{ steps.basic_vars.outputs.environment_name }}
      terraform_root_path: ${{ steps.detect-path.outputs.terraform_root_path || inputs.terraform_root_path }}

  terraform:
    runs-on: ubuntu-latest
    needs:
      - compute_basic_vars
    if: needs.compute_basic_vars.outputs.environment_name != '' && needs.compute_basic_vars.outputs.terraform_root_path != ''
    environment: ${{ needs.compute_basic_vars.outputs.environment_name }}
    concurrency:
      group: ${{ needs.compute_basic_vars.outputs.environment_name }}
      cancel-in-progress: false
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ vars.AWS_DEFAULT_REGION }}
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      RANCHER2_ACCESS_KEY: ${{ secrets.RANCHER2_ACCESS_KEY }}
      RANCHER2_SECRET_KEY: ${{ secrets.RANCHER2_SECRET_KEY }}
      RESOURCE_NAME: ${{ vars.RESOURCE_NAME }}
      TF_VAR_resource_name: ${{ vars.RESOURCE_NAME }}
      TERRAFORM_HTTP_CREDENTIALS: |
        github.com/Alfresco=alfresco-build:${{ secrets.BOT_GITHUB_TOKEN }}
      TERRAFORM_PRE_RUN: |
        set +x -euo pipefail
        if [ ! -x ./aws/install ]; then
          curl -sSf https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
          unzip -q awscliv2.zip
        fi
        ./aws/install
        if [ "${{ inputs.install_kubectl }}" == "true" ]; then
          if [ -z "${{ inputs.kubectl_version }}" ]; then
            echo "âš™ï¸ Will install latest stable kubectl..."
            KUBECTL_VERSION=$(curl -sSfL --max-time 10 --retry 3 https://dl.k8s.io/release/stable.txt)
            echo "âœ… Latest stable kubectl version resolved to ${KUBECTL_VERSION}"
          else
            echo "âš™ï¸ Will install kubectl version ${{ inputs.kubectl_version }}..."
            KUBECTL_VERSION="${{ inputs.kubectl_version }}"
          fi

          echo "ðŸ“¦ Downloading kubectl version ${KUBECTL_VERSION}..."
          curl -sSfL --max-time 30 --retry 3 -o kubectl "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
          curl -sSfL --max-time 10 --retry 3 -o kubectl.sha256 "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl.sha256"

          echo "ðŸ” Verifying kubectl checksum..."
          if ! echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check --status; then
            echo "âŒ Checksum verification failed for kubectl!"
            exit 1
          fi

          install -m 0755 kubectl /usr/local/bin/kubectl
          rm -f kubectl kubectl.sha256
          echo "âœ… kubectl installed successfully:"
          kubectl version --client
        fi

      # https://github.com/dflook/terraform-github-actions/tree/main/terraform-apply#applying-a-plan-using-a-comment
      PR_CHECKOUT_REF: refs/pull/${{ github.event.issue.number }}/merge
    steps:
      - name: Check environment requirements
        env:
          ENVIRONMENT_NAME: ${{ needs.compute_basic_vars.outputs.environment_name }}
        run: |
          if [ -z "$ENVIRONMENT_NAME" ]; then
            echo "Environment name should have been determined at this point, but it's empty. BUG?"
            exit 1
          fi
          if [ -z "${{ vars.RESOURCE_NAME }}" ]; then
            echo "RESOURCE_NAME must be set in the vars context of $ENVIRONMENT_NAME to provide a unique identifier"
            exit 1
          fi
          if [ -z "${{ vars.TERRAFORM_STATE_BUCKET }}" ]; then
            echo "TERRAFORM_STATE_BUCKET must be set in the vars context of $ENVIRONMENT_NAME to specify the S3 bucket used for terraform state storage"
            exit 1
          fi

      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          ref: ${{ github.event_name == 'issue_comment' && env.PR_CHECKOUT_REF || '' }}

      - name: Install OIDC Client from Core Package
        if: ${{ inputs.create_oidc_token_file }}
        run: npm install @actions/core@1.11.0 @actions/http-client@2.2.3

      - name: Request token
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        if: ${{ inputs.create_oidc_token_file }}
        id: idtoken
        with:
          script: |
            const coredemo = require('@actions/core')
            let id_token = await coredemo.getIDToken("sts.amazonaws.com")
            coredemo.setOutput('id_token', id_token)

      - name: Save token to file
        if: ${{ inputs.create_oidc_token_file }}
        run: echo "${{ steps.idtoken.outputs.id_token }}" >> idtoken.json

      - name: Assume AWS Role when AWS_ROLE_ARN is set
        uses: aws-actions/configure-aws-credentials@8df5847569e6427dd6c4fb1cf565c83acfa8afa7 # v6.0.0
        if: vars.AWS_ROLE_ARN != ''
        with:
          aws-region: ${{ env.AWS_DEFAULT_REGION}}
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          role-session-name: TerraformWorkflow

      - name: Load environment variables from yml
        uses: Alfresco/alfresco-build-tools/.github/actions/env-load-from-yaml@v15.4.0
        with:
          yml_path: ${{ needs.compute_basic_vars.outputs.terraform_root_path }}/tfenv.yml

      - name: Terraform validate
        if: (github.event_name == 'pull_request' || github.event_name == 'pull_request_review') && github.run_attempt == 1
        uses: dflook/terraform-validate@4cef5d8a4b92bcd88486e41e22a42942a382c9d6 # v2.2.3
        with:
          path: ${{ needs.compute_basic_vars.outputs.terraform_root_path }}
          backend_config: |
            bucket=${{ vars.TERRAFORM_STATE_BUCKET }}
            key=${{ vars.RESOURCE_NAME }}/${{ needs.compute_basic_vars.outputs.terraform_root_path }}/terraform.tfstate

      - name: Terraform plan
        uses: dflook/terraform-plan@7878bff63e2099cdc9be9a6f33cbbbf687f8f0fe # v2.2.3
        if: github.event_name == 'pull_request' || github.event_name == 'pull_request_review' || inputs.terraform_operation == 'plan' || (github.event_name == 'issue_comment' && contains(github.event.comment.body, 'terraform plan'))
        with:
          label: ${{ vars.RESOURCE_NAME }} ${{ needs.compute_basic_vars.outputs.terraform_root_path }}
          path: ${{ needs.compute_basic_vars.outputs.terraform_root_path }}
          var_file: |
            ${{ needs.compute_basic_vars.outputs.terraform_root_path }}/${{ inputs.tfvars_subfolder && format('{0}/', inputs.tfvars_subfolder) || '' }}common.tfvars
            ${{ needs.compute_basic_vars.outputs.terraform_root_path }}/${{ inputs.tfvars_subfolder && format('{0}/', inputs.tfvars_subfolder) || '' }}${{ needs.compute_basic_vars.outputs.environment_name }}.tfvars
          backend_config: |
            bucket=${{ vars.TERRAFORM_STATE_BUCKET }}
            key=${{ vars.RESOURCE_NAME }}/${{ needs.compute_basic_vars.outputs.terraform_root_path }}/terraform.tfstate

      - name: Terraform apply
        uses: dflook/terraform-apply@5489b988934a50bf1489d5b7c5253b46520a7dca # v2.2.3
        if: github.event_name == 'push' || inputs.terraform_operation == 'apply' || (github.event_name == 'issue_comment' && contains(github.event.comment.body, 'terraform apply'))
        with:
          label: ${{ vars.RESOURCE_NAME }} ${{ needs.compute_basic_vars.outputs.terraform_root_path }}
          path: ${{ needs.compute_basic_vars.outputs.terraform_root_path }}
          auto_approve: ${{ inputs.terraform_operation == 'apply' }}
          var_file: |
            ${{ needs.compute_basic_vars.outputs.terraform_root_path }}/${{ inputs.tfvars_subfolder && format('{0}/', inputs.tfvars_subfolder) || '' }}common.tfvars
            ${{ needs.compute_basic_vars.outputs.terraform_root_path }}/${{ inputs.tfvars_subfolder && format('{0}/', inputs.tfvars_subfolder) || '' }}${{ needs.compute_basic_vars.outputs.environment_name }}.tfvars
          backend_config: |
            bucket=${{ vars.TERRAFORM_STATE_BUCKET }}
            key=${{ vars.RESOURCE_NAME }}/${{ needs.compute_basic_vars.outputs.terraform_root_path }}/terraform.tfstate

      - name: Terraform destroy
        uses: dflook/terraform-destroy@b198834c4a4dd959f26649f2a9d24c59e9c9f205 # v2.2.3
        if: inputs.terraform_operation == 'destroy'
        with:
          path: ${{ needs.compute_basic_vars.outputs.terraform_root_path }}
          var_file: |
            ${{ needs.compute_basic_vars.outputs.terraform_root_path }}/${{ inputs.tfvars_subfolder && format('{0}/', inputs.tfvars_subfolder) || '' }}common.tfvars
            ${{ needs.compute_basic_vars.outputs.terraform_root_path }}/${{ inputs.tfvars_subfolder && format('{0}/', inputs.tfvars_subfolder) || '' }}${{ needs.compute_basic_vars.outputs.environment_name }}.tfvars
          backend_config: |
            bucket=${{ vars.TERRAFORM_STATE_BUCKET }}
            key=${{ vars.RESOURCE_NAME }}/${{ needs.compute_basic_vars.outputs.terraform_root_path }}/terraform.tfstate
